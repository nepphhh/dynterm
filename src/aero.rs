use crate::vec::{Vector, Angle, Kinematics};
use crate::interpolate::Linear;
use crate::rk4::rk4;
use crate::util::*;

use std::f64::consts::PI;

/// `Aerofoil` represents a simplified airfoil or control surface with specified aerodynamic coefficients.
/// Properties include area and pitch relative to the body vehicle. Aerodynamic coefficients are provided using interpolation objects.
/// The `Aerofoil` struct provides methods for calculating aerodynamic forces and moments acting on the airfoil
/// when attached to a `Vehicle`. It also allows setting the pitch angle of the airfoil, simulating control surface deflection.
pub struct Aerofoil<'a> { 
    area: f64,
    chord: f64,
    pitch: Angle,
    cl: &'a Linear<'a>,
    cd: &'a Linear<'a>,
    cm: &'a Linear<'a>,
}

impl<'a> Aerofoil<'a> {

    // Constructor
    pub fn new(area: f64, chord: f64, pitch: Angle, cl: &'a Linear<'a>, cd: &'a Linear<'a>, cm: &'a Linear<'a>) -> Aerofoil<'a> {
        Aerofoil { area, chord, pitch, cl, cd, cm }
    }

    // Control function
    pub fn set_pitch(&mut self, pitch: Angle) {
        self.pitch = pitch;
    }

    // Gets the angle of attack relative to a body vehicle
    #[inline] pub fn aoa(&self, k: &Kinematics, dk: &Kinematics) -> Angle {
        (k.angle() + self.pitch) - dk.direction()
    }

    // Calculates the dynamic pressure experienced, using altitude from k &
    // speed from magnitude of dk
    #[inline] pub fn dyn_pressure(&self, k: &Kinematics, dk: &Kinematics) -> f64 {
        0.5 * atmo_density(k.y()) * dk.magnitude().powi(2)
    }

    // Calculates the lift force if attached to a body vehicle. This is always
    // normal to the direction of motion
    pub fn lift_force(&self, k: &Kinematics, dk: &Kinematics) -> Vector {

        // Get the lift coefficient from the angle of attack 
        // (use orientation from k & velocity from dk)
        let lift_coeff = self.cl.interpolate(self.aoa(k, dk).deg());

        Vector::from_radians(
            self.area * lift_coeff * self.dyn_pressure(k, dk), 
            dk.direction().rad() + (PI/2.0) // Normal to direction of motion
        )
    }

    // Calcuates the lift force if attached to a body vehicle. This is always
    // against the direction of motion
    pub fn drag_force(&self, k: &Kinematics, dk: &Kinematics) -> Vector {

        // Get the drag coefficient from the angle of attack 
        // (use orientation from k & velocity from dk)
        let drag_coeff = self.cd.interpolate(self.aoa(k, dk).deg());

        Vector::from_radians(
            self.area * drag_coeff * self.dyn_pressure(k, dk), 
            dk.direction().rad() + PI // Antitangent direction of motion
        )
    }

    // Calculates the pitching moment generated by the airstream over the wing.
    // This is a free moment.
    pub fn pitching_moment(&self, k: &Kinematics, dk: &Kinematics) -> f64 {

        // Get the pitching moment coefficient from the angle of attack 
        // (use orientation from k & velocity from dk)
        let pitch_coeff = self.cm.interpolate(self.aoa(k, dk).deg());

        self.area * pitch_coeff * self.dyn_pressure(k, dk) * self.chord
    }
}

/// `Vehicle` represents a simplified aerospace vehicle with a massless main wing and stabilator.
/// The `Vehicle` struct provides methods for applying forces and moments to the vehicle using RK4.
pub struct Vehicle<'a> {
    pub mass: f64,
    pub length: f64,
    pub moment: f64,
    pub position: Kinematics,
    pub motion: Kinematics,
    pub wing: Aerofoil<'a>,
    pub elev: Aerofoil<'a>
}

impl<'a> Vehicle<'a> {
    pub fn new(mass: f64, length: f64, position: Kinematics, motion: Kinematics, wing: Aerofoil<'a>, elev: Aerofoil<'a>) -> Vehicle<'a> {
        Vehicle { 
            mass, 
            length,
            moment: mass * length.powi(2) / 12.0,
            position,
            motion,
            wing,
            elev,
        }
    }
    #[inline] pub fn aoa(&self) -> Angle {
        self.position.angle() - self.motion.direction()
    }

    #[allow(non_snake_case)]
    fn calculate_dynamics(&self, k: &Kinematics, dk: &Kinematics) -> Kinematics {

        let w: &Aerofoil = &self.wing;
        let e: &Aerofoil = &self.elev;
        let r_e = Vector::from_radians(self.length/2.0, k.angle().rad() + PI);
        let free_stream_unit: Vector = dk.direction().unit();

        // Body force
        let W = self.mass * Vector::new(0.0, -9.81);

        // Aero forces
        let F_w: Vector = w.lift_force(k, dk) + w.drag_force(k, dk);
        let F_e: Vector = e.lift_force(k, dk) + e.drag_force(k, dk);
        
        // Control 
        let aero_tangent: Vector = (free_stream_unit.cross(F_w + F_e)) * free_stream_unit;
        let T = Vector::from_radians(
            0_000.0, //aero_tangent.magnitude(), 
            k.angle().rad() + PI);

        // Return accleration & alpha
        Kinematics::new_raw(
            F_w + F_e + T + W,
            w.pitching_moment(k, dk) + e.pitching_moment(k, dk) + r_e.cross(F_e)
        ) / self.mass

    }


    // Use RK4 to apply a simple force to the object over the duration of a second
    pub fn apply_dynamics(&mut self, N: u16) {

        let h: f64 = 1.0 / N as f64;

        for i in 0..N {
            // Apply acceleration to velocity
            let f = 
                |t: f64, dk: Kinematics| t * self.calculate_dynamics(&self.position, &dk);
            self.motion = rk4(f, self.motion, 0.0, h);

            // Apply velocity to position
            let f = 
                |t: f64, _: Kinematics| t * self.motion;
            self.position = rk4(f, self.position, 0.0, h);
        }
    }
}